---
title: Using Bayesian Analysis to Examine the Impact of State Spending on Student
  Acheivement
author: "Taisha Ferguson"
date: "June 30, 2019"
output:
  html_document: default
  pdf_document: default
---
```{r}

```
# Introduction and Motivation

The goal of this project is to examine the relationship between individual state spending in the United States on education and the achievement of students in each state. The data set for the project comes from [Kaggle.com](https://www.kaggle.com/noriuk/us-educational-finances#naep.csv)^[Garrard, R. (2018, August 29). U.S. Educational Finances. Retrieved from https://www.kaggle.com/noriuk/us-educational-finances#naep.csv]. The data on state spending comes from the United States Census Bureau Annual Survey of School System Finances. This annual survey includes statistics on revenue, debt, and assets for all states, including the District of Columbia^[NDE Core Web. (n.d.). Retrieved from https://www.nationsreportcard.gov/ndecore/landing]. The National Assesment of Educational Progress (NAEP) is a national assessment that measures student achievement in various subjects^[US Census Bureau. (2017, May 04). Annual Survey of School System Finances Tables. Retrieved from https://www.census.gov/programs-surveys/school-finances/data/tables.html]. 


The following variables will be used to measure the relationship with state spending and student achievement:

  - Average test scores for each state (obtained from NAEP)
  - Per student spending on education (obtained from Census Bureau Annual Survey of School System Finances)



# Data and Data Preprossing
### Import Data

```{r}
naep <- read.csv("naep.csv", colClasses = c("integer", "factor", "character", "factor", "integer" ))
str(naep)

naep <- subset(naep, AVG_SCORE != "—")
naep <- subset(naep, AVG_SCORE != "‡")
naep$AVG_SCORE <- as.numeric(naep$AVG_SCORE)
summary(naep)


states <- read.csv("states.csv", header=TRUE)
summary(states)
```

### Format Data
NAEP Data:

  - Remove years before 2003
  - Remove tests years other than 4th Grade

Census Data:

- Create variable for per student speding by dividing total speding by number of enrolled students
- Divide pers student spending into bins (Low, Medium and High)

### Merge NAEP and Census Data
Merge NAEP and Census Data. The R merge function automatically removes cenus data that does not align with NAEP testing years. The remaining analysis years are (2003, 2005, 2007, 2009, 2011, 2013, and 2015)

```{r}
states$perpupil <- states$TOTAL_EXPENDITURE/states$ENROLL
states$bin <- cut(states$perpupil, 3, include.lowest=TRUE, labels=c("Low", "Med", "High"))
data <- merge(naep,states)
data <- subset(data, YEAR >= 2003)
data <- subset(data, TEST_YEAR == 4)
summary(data)
```

### Seperate Data into Math and Reading Scores

```{r}
datamath <- (subset(data, TEST_SUBJECT == "Mathematics"))
datareading <- (subset(data, TEST_SUBJECT == "Reading" ))
```

### Create Student Proficiency Variable
In this section the reading and math scores, the dependent variables, are transformed into binomial variables based on each states annual level of proficiency. The levels are as follows:

  - Math scores at 240 or above are labeled as 1 and below that is labeled as 0
  - Reading scores  at 220 or above are labeled as 1 and below that is labeled as 0

These scores were chosen because they are a little above the median value for each data set. NAEP has different thresholds for proficiency for reading(238) and math(249) scores. The NAEP levels were not chosen for this analysis due to thefact that the majority of data set is below their proficiency cut off.
```{r}
datamath$proficiency <- NA
for (i in 1:nrow(datamath)){
  if (datamath[i,"AVG_SCORE"] >= 240){
    datamath[i,"proficiency"] = 1}
  else {
    datamath[i,"proficiency"] = 0}}

datamath1 <- c("bin", "proficiency")
datamath1 <- datamath[datamath1]
summary(datamath1)
names(datamath1) <- c("s", "y")


datareading$proficiency <- NA
for (i in 1:nrow(datareading)){
  if (datareading[i,"AVG_SCORE"] >= 220){
    datareading[i,"proficiency"] = 1}
  else {
    datareading[i,"proficiency"] = 0}}

datareading1 <- c("bin", "proficiency")
datareading1 <- datareading[datareading1]
summary(datareading1)
names(datareading1) <- c("s", "y")
```
# Bayesian Analysis and Data Methods
The Bayesian Analysis method Markov chain Monte Carlo(MCMC) was used to analyze the different distributions of student proficiency in math and reading based on amount per student spending on education. Jags software will be used to implement to the MCMC chains. Jags is a program that automatically runs MCMC chains using Gibbs sampling^[Kruschke, J. K. (2015). Doing bayesian data analysis: A tutorial with R and BUGS. Beijing:Ji xie gong ye chu ban she.].

### Import Jags and Bayesian Functions from *Doing Bayesian Analysis* textbook.
Some of the functions used in the analysis below are imported to from *Doing Bayesian Analysis* by John Kruschke. You can use this [link](https://sites.google.com/site/doingbayesiandataanalysis/software-installation) to download the files below and import functions.
```{r}
source("DBDA2E-utilities.R")
```
### Create Function to Generate MCMC Chain
In order to generate the MCMC chain, you have to specify the model that will be used in the MCMC chains to derive the posterior distributions. Because the dependent variable student proficiency is binary, we can use the Binomial Distribution to model the likeihoood function. The likelihood function gives the probability of proficiency with the parameter theta. In this project theta follows a beta distribution with alpha and beta equal to 1. Alpha and beta equal to one is a uniform distribution that indicates that we do not have strong prior knowledge about the bias of theta.

```{r}
genMCMC = function( data , sName="s" , yName="y" ,  
                    numSavedSteps=50000 , saveName=NULL , thinSteps=1 ,
                    runjagsMethod=runjagsMethodDefault , 
                    nChains=nChainsDefault ) { 
  require(rjags)
  require(runjags)
  
  #The Data
  y = data[,yName]
  s = as.numeric(data[,sName]) 
  if ( any( y!=0 & y!=1 ) ) { stop("All y values must be 0 or 1.") }
  z = aggregate( y , by=list(s) , FUN=sum )$x
  N = aggregate( rep(1,length(y)) , by=list(s) , FUN=sum )$x
  Nsubj = length(unique(s))
  
  # Data in a list, for later shipment to JAGS:
  dataList = list(
    z = z ,
    N = N ,
    Nsubj = Nsubj
  )
  
  # The Model
  modelString = "
  model {
    for ( s in 1:Nsubj ) {
      z[s] ~ dbin( theta[s] , N[s] )
      theta[s] ~ dbeta(1,1) 
    }
    
  }
  " # close quote for modelString
  writeLines( modelString , con="TEMPmodel.txt" )
 
  
  # Intialize the Chains
  initsList = function() {
    thetaInit = rep(0,Nsubj)
    for ( sIdx in 1:Nsubj ) { 
      includeRows = ( s == sIdx ) 
      yThisSubj = y[includeRows]  
      resampledY = sample( yThisSubj , replace=TRUE ) 
      thetaInit[sIdx] = sum(resampledY)/length(resampledY) 
    }
    thetaInit = 0.001+0.998*thetaInit 
    return( list( theta=thetaInit ) )
  }
  
  # Run the Chains
  parameters = c( "theta") 
  adaptSteps = 500             
  burnInSteps = 500            
  useRunjags = TRUE
  if ( useRunjags ) {
    runJagsOut <- run.jags( method=runjagsMethod ,
                            model="TEMPmodel.txt" , 
                            monitor=parameters , 
                            data=dataList ,  
                            inits=initsList , 
                            n.chains=nChains ,
                            adapt=adaptSteps ,
                            burnin=burnInSteps , 
                            sample=ceiling(numSavedSteps/nChains) ,
                            thin=thinSteps ,
                            summarise=FALSE ,
                            plots=FALSE )
    codaSamples = as.mcmc.list( runJagsOut )
  } else {
    jagsModel = jags.model( "TEMPmodel.txt" , data=dataList , inits=initsList , 
                            n.chains=nChains , n.adapt=adaptSteps )
    #Burn-in:
    cat( "Burning in the MCMC chain...\n" )
    update( jagsModel , n.iter=burnInSteps )
    # Saved MCMC chain:
    cat( "Sampling final MCMC chain...\n" )
    codaSamples = coda.samples( jagsModel , variable.names=parameters , 
                                n.iter=ceiling(numSavedSteps*thinSteps/nChains), 
                                thin=thinSteps )
  }  
  
  if ( !is.null(saveName) ) {
    save( codaSamples , file=paste(saveName,"Mcmc.Rdata",sep="") )
  }
  return( codaSamples )
}
```
### Create Function to Summarize the Result of the Chains

```{r}
smryMCMC = function(  codaSamples , compVal=0.5 , rope=NULL , 
                      compValDiff=0.0 , ropeDiff=NULL , saveName=NULL ) {
  mcmcMat = as.matrix(codaSamples,chains=TRUE)
  Ntheta = length(grep("theta",colnames(mcmcMat)))
  summaryInfo = NULL
  rowIdx = 0
  for ( tIdx in 1:Ntheta ) {
    parName = paste0("theta[",tIdx,"]")
    summaryInfo = rbind( summaryInfo , 
                         summarizePost( mcmcMat[,parName] , compVal=compVal , ROPE=rope ) )
    rowIdx = rowIdx+1
    rownames(summaryInfo)[rowIdx] = parName
  }
  for ( t1Idx in 1:(Ntheta-1) ) {
    for ( t2Idx in (t1Idx+1):Ntheta ) {
      parName1 = paste0("theta[",t1Idx,"]")
      parName2 = paste0("theta[",t2Idx,"]")
      summaryInfo = rbind( summaryInfo , 
                           summarizePost( mcmcMat[,parName1]-mcmcMat[,parName2] ,
                                          compVal=compValDiff , ROPE=ropeDiff ) )
      rowIdx = rowIdx+1
      rownames(summaryInfo)[rowIdx] = paste0(parName1,"-",parName2)
    }
  }
  if ( !is.null(saveName) ) {
    write.csv( summaryInfo , file=paste(saveName,"SummaryInfo.csv",sep="") )
  }
  show( summaryInfo )
  return( summaryInfo )
}
```
### Create Funtion Plot the Results of MCMC Chain

```{r}
plotMCMC = function( codaSamples , data , compVal=0.5 , rope=NULL , 
                     compValDiff=0.0 , ropeDiff=NULL , 
                     saveName=NULL , saveType="jpg" ) {
  y = data$y
  s = as.numeric(data$s) 
  #Plot Posteriors
  mcmcMat = as.matrix(codaSamples,chains=TRUE)
  chainLength = NROW( mcmcMat )
  Ntheta = length(grep("theta",colnames(mcmcMat)))
  openGraph(width=2.5*Ntheta,height=2.0*Ntheta)
  par( mfrow=c(Ntheta,Ntheta) )
  for ( t1Idx in 1:(Ntheta) ) {
    for ( t2Idx in (1):Ntheta ) {
      parName1 = paste0("theta[",t1Idx,"]")
      parName2 = paste0("theta[",t2Idx,"]")
      if ( t1Idx > t2Idx) {  
        par( mar=c(3.5,3.5,1,1) , mgp=c(2.0,0.7,0) )
        nToPlot = 700
        ptIdx = round(seq(1,chainLength,length=nToPlot))
        plot ( mcmcMat[ptIdx,parName2] , mcmcMat[ptIdx,parName1] , cex.lab=1.75 ,
               xlab=parName2 , ylab=parName1 , col="skyblue" )
      } else if ( t1Idx == t2Idx ) {
        par( mar=c(3.5,1,1,1) , mgp=c(2.0,0.7,0) )
        postInfo = plotPost( mcmcMat[,parName1] , cex.lab = 1.75 , 
                             compVal=compVal , ROPE=rope , cex.main=1.5 ,
                             xlab=parName1 , main="" )
        includeRows = ( s == t1Idx ) 
        dataPropor = sum(y[includeRows])/sum(includeRows) 
        points( dataPropor , 0 , pch="+" , col="red" , cex=3 )
      } else if ( t1Idx < t2Idx ) {
        par( mar=c(3.5,1,1,1) , mgp=c(2.0,0.7,0) )
        postInfo = plotPost(mcmcMat[,parName1]-mcmcMat[,parName2] , cex.lab = 1.75 , 
                            compVal=compValDiff , ROPE=ropeDiff , cex.main=1.5 ,
                            xlab=paste0(parName1,"-",parName2) , main="" )
        includeRows1 = ( s == t1Idx ) 
        dataPropor1 = sum(y[includeRows1])/sum(includeRows1) 
        includeRows2 = ( s == t2Idx ) 
        dataPropor2 = sum(y[includeRows2])/sum(includeRows2) 
        points( dataPropor1-dataPropor2 , 0 , pch="+" , col="red" , cex=3 )
      }
    }
  }
  if ( !is.null(saveName) ) {
    saveGraph( file=paste(saveName,"Post",sep=""), type=saveType)
  }
}
```

### Apply Functions to the Math Data Set
```{r}
fileNameRoot = "Ferguson-" 
graphFileType = "pdf" 
#Generate MCMC Chain
mcmcCoda = genMCMC( data=datamath1 , numSavedSteps=50000 , saveName=fileNameRoot )
parameterNames = varnames(mcmcCoda) 
for ( parName in parameterNames ) {
  diagMCMC( codaObject=mcmcCoda , parName=parName , 
            saveName=fileNameRoot , saveType=graphFileType )
}
#Get Summary Info
summaryInfo = smryMCMC( mcmcCoda , compVal=NULL ,
                        compValDiff=0.0 , saveName=fileNameRoot )

```


```{r}
#Plot Posteriors
plotMCMC( mcmcCoda , data=datamath1 , compVal=NULL ,
          compValDiff=0.0 , 
          saveName=fileNameRoot , saveType=graphFileType )
#------------------------------------------------------------------------------- 
```

```{r}

```

# Observations from Math Score Results
The results of the summary are described in terms of theta[1], theta[2], theta[3]. These values correspond to the following per student funding groups:

  - theta[1] = Low Per Student Funding Group ($6,000- $14,000 per student)
  - theta[2] = Medium Per Student Funding Group ($14,000 - $22,000 per student)
  - theta[3] = High Per Student Funding Group ($22,000-$30,000 per student)

The graphs of the MCMC summary chains show the accucuary of MCMC chains. The param value, the ESS score, and the shrink factor all indicate that the all of the samples chains were similar to each other and were representative of the full sample space.

The graphs of the posteriors of theta[1], theta[2], and theta[3], and the differences between the 3 indicate that there are in factor major differences in student acheivement based on spending per student. In particular, the change in probability of proficiency changes from a mode of .38 to a mode of .69 when moving from low to moderate funding. Interestingly, there is a decrease in the mode when moving from moderate to high spending. The decrease from moderate to high is an indication of other factors that may contribute to student acheivement beyond spending per student.




## Apply Functions to Reading Data Set

```{r}
fileNameRoot = "Ferguson2-" 
graphFileType = "pdf" 

#Generate MCMC Chain
mcmcCoda = genMCMC( data=datareading1 , numSavedSteps=50000 , saveName=fileNameRoot )

parameterNames = varnames(mcmcCoda)
for ( parName in parameterNames ) {
  diagMCMC( codaObject=mcmcCoda , parName=parName , 
            saveName=fileNameRoot , saveType=graphFileType )
}

#Get Summary of Chains
summaryInfo = smryMCMC( mcmcCoda , compVal=NULL ,
                        compValDiff=0.0 , 
                        saveName=fileNameRoot )

#Plot Posteriors
plotMCMC( mcmcCoda , data=datareading1 , compVal=NULL , 
          compValDiff=0.0 , 
          saveName=fileNameRoot , saveType=graphFileType )
#------------------------------------------------------------------------------- 

```

```{r}

```

```{r}

```
# Observations from Reading Score Results
The results of the reading data set are very similar to the results of the math data set. The change in probability of proficiency changes from a mode of .47 to a mode of .78 when moving from low to moderate funding but decrease to a mode of .69 when moving to high spending.

# Conclusion
The goal of this project was to examine the relationship between individual state spending in the United States on education and the achievement of students in each state. Using the Bayesian analysis method MCMC and Jags software, it was shown that inceasing spending per student from a low range of $6,000-$14,000  per student to a moderate range of $14,000-$22,000 is correlated with a significantly higher probablilty of student proficiency in both math and reading. Suprisingly however, increased spedinding from the moderate range to high range of $22,000-$30,000 per student is correlated with a lower probabliltiy of student proficiency in both math and reading.


# References



```{r}
